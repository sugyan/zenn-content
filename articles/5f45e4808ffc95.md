---
title: "AtCoderのとある問題でCode Golfに挑戦した記録 (Python3)"
emoji: "🐍"
type: "tech"
topics: ["python", "atcoder", "codegolf"]
published: false
---

## きっかけ

最近 [@yanecoder](https://twitter.com/yanecoder) さんが [AtCoder](https://atcoder.jp/) の問題を解きまくっていて、さらにshortest記録更新にも熱心に取り組んでいるので、自分も以前に多少は嗜んでいたしと対抗心を燃やして挑んでみたところ、多くの学びがあったので記録として残しておく。

※使用言語はPython3です


## Code Golf とは

とにかく短いコード(byte数)で目的を達成するプログラムを書くこと。

https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B4%E3%83%AB%E3%83%95

AtCoder では `AC` をとれれば目的達成といえるし、言語別にすべての提出のコード長も表示されるので分かりやすい。


## お題

本記事で取り上げる問題は、これ。

https://atcoder.jp/contests/iroha2019-day3/tasks/iroha2019_day3_e

```
5
/
\
/
/
\
```

のような入力が与えられて、「く」のように等しい長さの `/` と `\` が連続しているものをカウントする、というもの。
上の例だと 2-3行目が `/` `\` で等しいが、4-6行目は `//` `\` と `/` の方が長いので対象外となり、正解は `1` となる。


## 参考解答例 (134 Byte)

先月までの時点での、Python3の最短 `AC` コードはこれ。

https://atcoder.jp/contests/iroha2019-day3/submissions/10517249

```python
_,*c=open(0)
a=b=s=0
for c in c:
  if c<'\\':
    if b:
      s+=a==b
      a,b=1,0
    else:a+=1
  else:b+=1
print(s+(a==b))
```

これでも十分に短くてすごいのだけど、ここからさらに短いコードを目指していく。

### 解読

まず入力の読み取りは `input()` を使わずに `open(0)` を使う。Golfでは常套テクニックのようだ。

https://qiita.com/neko_the_shadow/items/521d1361820c42547741

`_,*c=` で代入すれば、 `c` に2行目以降の文字列配列を受け取れるので、それを順番に見ていく。

`a` は `/` の連続する数をカウントし、 `b` は `\` の連続する数をカウントするもの、のようだ。 `s` が対象の出現カウント。

`c<'\\'` すなわち `/` の行であれば `b` を判定し、 `b` が正かつ `a` と同値ならば `s` を増加させる。 `s += (a==b)` は比較結果のbool値を暗黙的に数値として `+=` することで `True` のときだけ `+1` するという意味になる。
`b` の真偽判定をする場面は `\` が少なくとも1つ以上出現した後の `/` 、つまり `\` `/` と折り返した場面なので、その時点のみ それまで続いていたものが「く」になっているか否かを判定すれば良い、ということになる(そして両者のカウントをリセットする)。ただし最終行が `\` で終わった場合にその判定ができないので、最後に `print` するときに最終的な `a==b` を足してあげることで漏れをなくしている。


## 2022年11月 始まり (116 Byte)

[yaneorao](https://atcoder.jp/users/yaneurao) さんによる記録更新。

https://atcoder.jp/contests/iroha2019-day3/submissions/36137106

```python
N,*C=open(0)
S=[0]*9**6
i=l=0
for c,*_ in C:i+=l!=c;S[i]+=(c>";")*2-1;l=c
print(sum(-a==b>0for a,b in zip(S,S[1:])))
```

### 解読

`S` にはそれぞれ `/` と `\` の連続出現回数を交互に正負逆で入れていき、あとでその隣り合う数値を確認して同値であるものを数え上げる、という方式。
詳細は割愛。


## 2桁台に突入 (94 Byte)

yaneurao さんが自ら記録更新。

https://atcoder.jp/contests/iroha2019-day3/submissions/36192099

```python
n,*A=open(0)
a=b=s=l=0
for c,*_ in A+[n]:
 if l!=c:s+=a==b>0!=";"<l;a=b;b=0
 b+=1;l=c
print(s)
```

### 解読

`for c,*_ in` とすることで改行を除く文字を確実に取得できる。
どうやらテストケースによってファイル末尾に改行があったりなかったりするようで、 `open(0)` から行ごとに取っていると `"/\n"` と `"/"` で同じはずなのに改行有無の違いで正しく判定できないことがある。

`l` に直前の `c` の値を入れながら `for` 文の中で比較していくことで、 `/` と `\` が切り替わったタイミングを判定。
ただそれだけだと `/` → `\` の変化か `\` → `/` の変化かを判定できないので、`";"` より大きかったか否か、を見る。ASCIIで `"/"` と `"\"` の間であれば何でも良さそうではある。

`a` と `b` はそれぞれ 直前の連続出現回数と現在の連続出現回数を保持するもののようだ。

`\` `\` のように `\` の連続で終わる場合にも判定をする必要があるので `A+[n]` として1回ぶん多くループを回す。
`n` は入力数を示す最初の数値行でしかないので必ず `if` 文の判定には入ることになる。なるほど…


## 正規表現で挑戦 (109 Byte)

このあたりのタイミングで私が参戦。
何かまったく違うアプローチで一発逆転できないかな、と思い、正規表現を利用した解法を試してみた。

https://atcoder.jp/contests/iroha2019-day3/submissions/36191733

```python
import re;print(sum([len(m[0])==len(m[1])for m in re.findall(r'(/+)(\\+)',"".join(map(str.strip,open(0))))]))
```

1行にはおさめることができたが あまり短くはならず、109 Byte…。

### 解説

まずすべての入力を繋げた `"/\//\"` のような文字列を作ってしまう。
これは `"".join(map(str.strip,open(0)))` で改行取り除いて繋ぎ直すことで得られる。

この文字列に対して `re.findall(r'(/+)(\\+)'` とすることで 「`/` が1回以上連続した後に `\` が1回以上連続したもの」の塊を取得できる。
ので、それぞれの長さが等しいものだけを数え上げれば良い。


`a{m}b{m}` のように「同じ回数の繰り返し」を指定できる正規表現があれば長さの判定が要らなくて済みそうなのに…と思ったが、PCREにはあるがPythonの正規表現では使えないようだった。

https://regex101.com/r/CCEssq/1


## 正規表現 短縮版 (103 Byte)

どうにかもっと短くしたいと思い試行錯誤して、前述のを少しだけ縮めることができた。

https://atcoder.jp/contests/iroha2019-day3/submissions/36193754

```python
import re;print(sum([sum(map(ord,m))%139<1for m in re.findall(r'\\+/+',open(0).read().strip()[::-2])]))
```

### 解説

まず全部繋げた文字列を作るのに、 `open(0).read().strip()[::-2]` というものを使った。

`"".join(map(str.strip,open(0)))` だと 31文字つかってしまう。他に `open(0).read().replace("\n","")` と `read()` して全文を取得してから改行だけ取り除く書き方もあるが、これも同じ文字数。`re` を使っている場合は `replace` の代わりに `re.sub` を使うことで1文字は短縮できるが、それでも微妙。

そもそも2行目以降はすべて `/` か `\` のどちらか + 改行だけなので、1文字ずつとばして取得すれば目当てのものが取れるのではないか、と思い付いた。
ので `open(0).read()[::2]` のようなテクニックが使える。しかし1行目は何桁になるか分からず、ズレると困る。それなら逆に末尾から取ってしまえば良い。 `[::-2]` で末尾から1文字とばしで取得できる。
しかし今度はファイル末尾に改行があったりなかったりする問題にぶち当たるので、仕方ないので `.strip()` を入れてやる。それでも 28文字と短い記述にすることができた。

逆から読むことになるので、正規表現の `/` と `\` の順番も入れ替えてやる必要はある。


そして連続出現回数判定を、それぞれの長さを比較するのではなく `sum(map(ord,m))%139<1` というズルい方法にしてみた。
`/` `\` それぞれの `ord()` を取ると `47` と `92` となる。

```python
>>> ord("/") + ord("\\")
139
```

ので、`/` と `\` だけでできた文字列では「各文字の `ord()` を足し合わせたものが `139` で割り切れたとき」に同じ出現回数だと判断できそうだな、と。

考えれば分かるがこれは所謂「嘘解法」で、例えば `/` が 140回続いた後に `\` が1回、のように出現回数の**差**が `139` の倍数だったときにも `True` としてしまうので正しい答えになない。
が、試しにsubmitしてみたら通ってしまったので一応目的は達成している…。どうやらそういったテストケースは存在していなかったようだ。


#### 余談

ちなみにこの `sum(map(ord, ... )) % ...` という `ord()` を合計して判定するテクニックは自分のお気に入りで、以下の問題などでも同様の手法で最短記録更新に貢献した。(これは嘘解法ではない、はず)

https://atcoder.jp/contests/agc003/tasks/agc003_a


## 嘘解法による発展 (88 Byte)

TODO