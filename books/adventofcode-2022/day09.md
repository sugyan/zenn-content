---
title: "Day 9: Rope Bridge"
---

https://adventofcode.com/2022/day/9

物理シミュレーション。


## part1

```
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
```

のような入力が与えられます。

複数の結び目からなるロープを考えたときの両端を **先頭** と **末尾** とし、各行は先頭が動く方向とステップ数を表します。
初期状態は先頭から末尾まですべて同じ位置にあるとします。

結び目同士は、2次元平面上で **常に繋がっている** 必要があります(斜めの隣接も、重なっている状態も、繋がっていると見做します)。

先頭と末尾だけからなる短いロープを考えたとき、
もし先頭(`H`)がある方向に2ステップ動いた場合、末尾(`T`)も繋がっている状態を保つために1ステップ移動します。

```
.....    .....    .....
.TH.. -> .T.H. -> ..TH.
.....    .....    .....

...    ...    ...
.T.    .T.    ...
.H. -> ... -> .T.
...    .H.    .H.
...    ...    ...
```

また、同じ行でも同じ列でもない位置にいて離れようとする場合、斜めに1ステップ移動してついていきます。

```
.....    .....    .....
.....    ..H..    ..H..
..H.. -> ..... -> ..T..
.T...    .T...    .....
.....    .....    .....

.....    .....    .....
.....    .....    .....
..H.. -> ...H. -> ..TH.
.T...    .T...    .....
.....    .....    .....
```

この法則に従って先頭を動かした後、末尾が一度でも訪れた位置はいくつになるでしょうか、という問題です。
上述の例では、先頭と末尾は以下のような動きをすることになります(`s`はスタート地点を表します)。

```
== Initial State ==

......
......
......
......
H.....  (H covers T, s)

== R 4 ==

......
......
......
......
TH....  (T covers s)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H covers T)
......
s.....

......
......
.TH...
......
s.....
```

結果として、末尾が通過した場所を `#` で表すと

```
..##..
...##.
.####.
....#.
s###..
```

のようになり、スタート地点も含めて **`13`** が解となります。

### 考え方

法則の通りにシミュレーションを行うだけです。
1ステップずつ先頭を動かし、横方向または縦方向に距離が `2` 以上離れたら末尾の方を動かす、という操作を繰り返します。
座標平面を用意する必要はなく、座標の値だけを管理して更新しながら末尾の位置を `Set` など集合に記録しておけば、最後にそのサイズを取得することで解を求められます。


## part2

part1 では先頭と末尾だけの2つの結び目のロープを考えていましたが、今度は **`10`** 個の結び目からなるロープを考えます。
先頭は同様に動き、その他の結び目は同じ法則で前の結び目についていきます。
そうすると、末尾が一度でも訪れた位置はいくつになるでしょうか、という問題です。
前述の例では、以下のような動きをすることになります。

```
== Initial State ==

......
......
......
......
H.....  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

== R 4 ==

......
......
......
......
1H....  (1 covers 2, 3, 4, 5, 6, 7, 8, 9, s)

......
......
......
......
21H...  (2 covers 3, 4, 5, 6, 7, 8, 9, s)

......
......
......
......
321H..  (3 covers 4, 5, 6, 7, 8, 9, s)

......
......
......
......
4321H.  (4 covers 5, 6, 7, 8, 9, s)

== U 4 ==

......
......
......
....H.
4321..  (4 covers 5, 6, 7, 8, 9, s)

......
......
....H.
.4321.
5.....  (5 covers 6, 7, 8, 9, s)

......
....H.
....1.
.432..
5.....  (5 covers 6, 7, 8, 9, s)

....H.
....1.
..432.
.5....
6.....  (6 covers 7, 8, 9, s)

== L 3 ==

...H..
....1.
..432.
.5....
6.....  (6 covers 7, 8, 9, s)

..H1..
...2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

.H1...
...2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== D 1 ==

..1...
.H.2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== R 4 ==

..1...
..H2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

..1...
...H..  (H covers 2)
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

......
...1H.  (1 covers 2)
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

......
...21H
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== D 1 ==

......
...21.
..43.H
.5....
6.....  (6 covers 7, 8, 9, s)

== L 5 ==

......
...21.
..43H.
.5....
6.....  (6 covers 7, 8, 9, s)

......
...21.
..4H..  (H covers 3)
.5....
6.....  (6 covers 7, 8, 9, s)

......
...2..
..H1..  (H covers 4; 1 covers 3)
.5....
6.....  (6 covers 7, 8, 9, s)

......
...2..
.H13..  (1 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

......
......
H123..  (2 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

== R 2 ==

......
......
.H23..  (H covers 1; 2 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

......
......
.1H3..  (H covers 2, 4)
.5....
6.....  (6 covers 7, 8, 9, s)
```

末尾である `9` は最後までスタート地点から動かないので、 **`1`** が解となります。

より大きな動きをする例として

```
R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
```

の場合は、

```
== Initial State ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........H..............  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)
..........................
..........................
..........................
..........................
..........................

== R 5 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........54321H.........  (5 covers 6, 7, 8, 9, s)
..........................
..........................
..........................
..........................
..........................

== U 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
................H.........
................1.........
................2.........
................3.........
...............54.........
..............6...........
.............7............
............8.............
...........9..............  (9 covers s)
..........................
..........................
..........................
..........................
..........................

== L 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
........H1234.............
............5.............
............6.............
............7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 3 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
.........2345.............
........1...6.............
........H...7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== R 17 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
................987654321H
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 10 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s.........98765
.........................4
.........................3
.........................2
.........................1
.........................H

== L 25 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
H123456789................

== U 20 ==

H.........................
1.........................
2.........................
3.........................
4.........................
5.........................
6.........................
7.........................
8.........................
9.........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................
```

という動きを経て、末尾の通った場所は

```
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
#.........................
#.............###.........
#............#...#........
.#..........#.....#.......
..#..........#.....#......
...#........#.......#.....
....#......s.........#....
.....#..............#.....
......#............#......
.......#..........#.......
........#........#........
.........########.........
```

となり、 **`36`** が解となります。

### 考え方

part1 と同様にシミュレーションを行うだけです。
10個の結び目の座標を配列で管理すると、先頭 `knots[0]` を動かした後に `1` 番目以降のものを `knots[i]` が `knots[i-1]` についていくよう順番に座標を更新していくことで簡単に実装できます。
part1 はこの配列がサイズ `2` だっただけ、と考えることができます。


## 実装例

### Python

```python
import sys
from typing import TextIO


class Solution:
    def __init__(self, io: TextIO) -> None:
        def parse(line: str) -> tuple[complex, int]:
            return {"U": 1j, "D": -1j, "L": -1, "R": 1}[line[0]], int(line[2:])

        self.motions = list(map(parse, io))

    def part1(self) -> int:
        return self.tail_visited(2)

    def part2(self) -> int:
        return self.tail_visited(10)

    def tail_visited(self, knots_count: int) -> int:
        """`knots_count`個の結び目の、末尾が通った場所の数を返す"""
        knots = [0j] * knots_count
        tails = set()
        for d, steps in self.motions:
            for _ in range(steps):
                knots[0] += d
                for i in range(1, knots_count):
                    diff = knots[i - 1] - knots[i]
                    if abs(diff) >= 2.0:
                        knots[i] += complex(
                            (diff.real > 0) - (diff.real < 0),
                            (diff.imag > 0) - (diff.imag < 0),
                        )
                tails.add(knots[-1])
        return len(tails)


if __name__ == "__main__":
    solution = Solution(sys.stdin)
    print(f"Part 1: {solution.part1()}")
    print(f"Part 2: {solution.part2()}")
```

普通に `tuple[int, int]` で2次元座標を管理しても良いのですが、 `complex` を使って複素平面で表して計算してみました。座標の移動や距離の計算が少しだけ楽になります。

### Rust

```rust
use std::collections::HashSet;
use std::io::{BufRead, BufReader, Read};

struct Solution {
    motions: Vec<((i32, i32), u32)>,
}

impl Solution {
    fn new(r: impl Read) -> Self {
        Self {
            motions: BufReader::new(r)
                .lines()
                .filter_map(Result::ok)
                .map(|s| {
                    (
                        match &s[..1] {
                            "U" => (0, 1),
                            "D" => (0, -1),
                            "L" => (-1, 0),
                            "R" => (1, 0),
                            _ => unreachable!(),
                        },
                        s[2..].parse().unwrap(),
                    )
                })
                .collect(),
        }
    }
    fn part1(&self) -> usize {
        self.tail_visited(2)
    }
    fn part2(&self) -> usize {
        self.tail_visited(10)
    }
    fn tail_visited(&self, knots_count: usize) -> usize {
        let mut knots = vec![(0, 0); knots_count];
        let mut hs = HashSet::new();
        for &(d, n) in &self.motions {
            for _ in 0..n {
                knots[0].0 += d.0;
                knots[0].1 += d.1;
                for i in 1..knots_count {
                    let diff = (knots[i - 1].0 - knots[i].0, knots[i - 1].1 - knots[i].1);
                    if diff.0.abs() > 1 || diff.1.abs() > 1 {
                        knots[i].0 += diff.0.signum();
                        knots[i].1 += diff.1.signum();
                    }
                }
                hs.insert(knots[knots_count - 1]);
            }
        }
        hs.len()
    }
}

fn main() {
    let solution = Solution::new(std::io::stdin().lock());
    println!("Part 1: {}", solution.part1());
    println!("Part 2: {}", solution.part2());
}
```

こちらは `(i32, i32)` で実装しています。ついていこうと動くときに移動すべき量(または移動しないか)をそれぞれ `.signum()` で計算できて便利です。
